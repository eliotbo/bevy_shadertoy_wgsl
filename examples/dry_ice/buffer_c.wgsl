var<private> location: vec2<i32>;

fn div(x: i32, y: i32) -> f32 {
	return textureLoad(buffer_b, vec2<i32>(location + vec2<i32>(x, y))).x;
} 

fn getDiv() -> f32 {
	var p: f32 = 0.;
	p = p + (1. * div(-9, 0));
	p = p + (9. * div(-8, -1));
	p = p + (4. * div(-8, 0));
	p = p + (9. * div(-8, 1));
	p = p + (36. * div(-7, -2));
	p = p + (32. * div(-7, -1));
	p = p + (97. * div(-7, 0));
	p = p + (32. * div(-7, 1));
	p = p + (36. * div(-7, 2));
	p = p + (84. * div(-6, -3));
	p = p + (112. * div(-6, -2));
	p = p + (436. * div(-6, -1));
	p = p + (320. * div(-6, 0));
	p = p + (436. * div(-6, 1));
	p = p + (112. * div(-6, 2));
	p = p + (84. * div(-6, 3));
	p = p + (126. * div(-5, -4));
	p = p + (224. * div(-5, -3));
	p = p + (1092. * div(-5, -2));
	p = p + (1280. * div(-5, -1));
	p = p + (2336. * div(-5, 0));
	p = p + (1280. * div(-5, 1));
	p = p + (1092. * div(-5, 2));
	p = p + (224. * div(-5, 3));
	p = p + (126. * div(-5, 4));
	p = p + (126. * div(-4, -5));
	p = p + (280. * div(-4, -4));
	p = p + (1694. * div(-4, -3));
	p = p + (2752. * div(-4, -2));
	p = p + (6656. * div(-4, -1));
	p = p + (6464. * div(-4, 0));
	p = p + (6656. * div(-4, 1));
	p = p + (2752. * div(-4, 2));
	p = p + (1694. * div(-4, 3));
	p = p + (280. * div(-4, 4));
	p = p + (126. * div(-4, 5));
	p = p + (84. * div(-3, -6));
	p = p + (224. * div(-3, -5));
	p = p + (1694. * div(-3, -4));
	p = p + (3520. * div(-3, -3));
	p = p + (11016. * div(-3, -2));
	p = p + (16128. * div(-3, -1));
	p = p + (24608. * div(-3, 0));
	p = p + (16128. * div(-3, 1));
	p = p + (11016. * div(-3, 2));
	p = p + (3520. * div(-3, 3));
	p = p + (1694. * div(-3, 4));
	p = p + (224. * div(-3, 5));
	p = p + (84. * div(-3, 6));
	p = p + (36. * div(-2, -7));
	p = p + (112. * div(-2, -6));
	p = p + (1092. * div(-2, -5));
	p = p + (2752. * div(-2, -4));
	p = p + (11016. * div(-2, -3));
	p = p + (21664. * div(-2, -2));
	p = p + (47432. * div(-2, -1));
	p = p + (59712. * div(-2, 0));
	p = p + (47432. * div(-2, 1));
	p = p + (21664. * div(-2, 2));
	p = p + (11016. * div(-2, 3));
	p = p + (2752. * div(-2, 4));
	p = p + (1092. * div(-2, 5));
	p = p + (112. * div(-2, 6));
	p = p + (36. * div(-2, 7));
	p = p + (9. * div(-1, -8));
	p = p + (32. * div(-1, -7));
	p = p + (436. * div(-1, -6));
	p = p + (1280. * div(-1, -5));
	p = p + (6656. * div(-1, -4));
	p = p + (16128. * div(-1, -3));
	p = p + (47432. * div(-1, -2));
	p = p + (92224. * div(-1, -1));
	p = p + (163476. * div(-1, 0));
	p = p + (92224. * div(-1, 1));
	p = p + (47432. * div(-1, 2));
	p = p + (16128. * div(-1, 3));
	p = p + (6656. * div(-1, 4));
	p = p + (1280. * div(-1, 5));
	p = p + (436. * div(-1, 6));
	p = p + (32. * div(-1, 7));
	p = p + (9. * div(-1, 8));
	p = p + (1. * div(0, -9));
	p = p + (4. * div(0, -8));
	p = p + (97. * div(0, -7));
	p = p + (320. * div(0, -6));
	p = p + (2336. * div(0, -5));
	p = p + (6464. * div(0, -4));
	p = p + (24608. * div(0, -3));
	p = p + (59712. * div(0, -2));
	p = p + (163476. * div(0, -1));
	p = p + (409744. * div(0, 0));
	p = p + (163476. * div(0, 1));
	p = p + (59712. * div(0, 2));
	p = p + (24608. * div(0, 3));
	p = p + (6464. * div(0, 4));
	p = p + (2336. * div(0, 5));
	p = p + (320. * div(0, 6));
	p = p + (97. * div(0, 7));
	p = p + (4. * div(0, 8));
	p = p + (1. * div(0, 9));
	p = p + (9. * div(1, -8));
	p = p + (32. * div(1, -7));
	p = p + (436. * div(1, -6));
	p = p + (1280. * div(1, -5));
	p = p + (6656. * div(1, -4));
	p = p + (16128. * div(1, -3));
	p = p + (47432. * div(1, -2));
	p = p + (92224. * div(1, -1));
	p = p + (163476. * div(1, 0));
	p = p + (92224. * div(1, 1));
	p = p + (47432. * div(1, 2));
	p = p + (16128. * div(1, 3));
	p = p + (6656. * div(1, 4));
	p = p + (1280. * div(1, 5));
	p = p + (436. * div(1, 6));
	p = p + (32. * div(1, 7));
	p = p + (9. * div(1, 8));
	p = p + (36. * div(2, -7));
	p = p + (112. * div(2, -6));
	p = p + (1092. * div(2, -5));
	p = p + (2752. * div(2, -4));
	p = p + (11016. * div(2, -3));
	p = p + (21664. * div(2, -2));
	p = p + (47432. * div(2, -1));
	p = p + (59712. * div(2, 0));
	p = p + (47432. * div(2, 1));
	p = p + (21664. * div(2, 2));
	p = p + (11016. * div(2, 3));
	p = p + (2752. * div(2, 4));
	p = p + (1092. * div(2, 5));
	p = p + (112. * div(2, 6));
	p = p + (36. * div(2, 7));
	p = p + (84. * div(3, -6));
	p = p + (224. * div(3, -5));
	p = p + (1694. * div(3, -4));
	p = p + (3520. * div(3, -3));
	p = p + (11016. * div(3, -2));
	p = p + (16128. * div(3, -1));
	p = p + (24608. * div(3, 0));
	p = p + (16128. * div(3, 1));
	p = p + (11016. * div(3, 2));
	p = p + (3520. * div(3, 3));
	p = p + (1694. * div(3, 4));
	p = p + (224. * div(3, 5));
	p = p + (84. * div(3, 6));
	p = p + (126. * div(4, -5));
	p = p + (280. * div(4, -4));
	p = p + (1694. * div(4, -3));
	p = p + (2752. * div(4, -2));
	p = p + (6656. * div(4, -1));
	p = p + (6464. * div(4, 0));
	p = p + (6656. * div(4, 1));
	p = p + (2752. * div(4, 2));
	p = p + (1694. * div(4, 3));
	p = p + (280. * div(4, 4));
	p = p + (126. * div(4, 5));
	p = p + (126. * div(5, -4));
	p = p + (224. * div(5, -3));
	p = p + (1092. * div(5, -2));
	p = p + (1280. * div(5, -1));
	p = p + (2336. * div(5, 0));
	p = p + (1280. * div(5, 1));
	p = p + (1092. * div(5, 2));
	p = p + (224. * div(5, 3));
	p = p + (126. * div(5, 4));
	p = p + (84. * div(6, -3));
	p = p + (112. * div(6, -2));
	p = p + (436. * div(6, -1));
	p = p + (320. * div(6, 0));
	p = p + (436. * div(6, 1));
	p = p + (112. * div(6, 2));
	p = p + (84. * div(6, 3));
	p = p + (36. * div(7, -2));
	p = p + (32. * div(7, -1));
	p = p + (97. * div(7, 0));
	p = p + (32. * div(7, 1));
	p = p + (36. * div(7, 2));
	p = p + (9. * div(8, -1));
	p = p + (4. * div(8, 0));
	p = p + (9. * div(8, 1));
	p = p + (1. * div(9, 0));
	return p / 1048576.;
} 

fn pre(x: i32, y: i32) -> f32 {
	return textureLoad(buffer_d, vec2<i32>(location + vec2<i32>(x, y))).x;
} 

fn getPre() -> f32 {
	var p: f32 = 0.;
	p = p + (1. * pre(-10, 0));
	p = p + (10. * pre(-9, -1));
	p = p + (10. * pre(-9, 1));
	p = p + (45. * pre(-8, -2));
	p = p + (100. * pre(-8, 0));
	p = p + (45. * pre(-8, 2));
	p = p + (120. * pre(-7, -3));
	p = p + (450. * pre(-7, -1));
	p = p + (450. * pre(-7, 1));
	p = p + (120. * pre(-7, 3));
	p = p + (210. * pre(-6, -4));
	p = p + (1200. * pre(-6, -2));
	p = p + (2025. * pre(-6, 0));
	p = p + (1200. * pre(-6, 2));
	p = p + (210. * pre(-6, 4));
	p = p + (252. * pre(-5, -5));
	p = p + (2100. * pre(-5, -3));
	p = p + (5400. * pre(-5, -1));
	p = p + (5400. * pre(-5, 1));
	p = p + (2100. * pre(-5, 3));
	p = p + (252. * pre(-5, 5));
	p = p + (210. * pre(-4, -6));
	p = p + (2520. * pre(-4, -4));
	p = p + (9450. * pre(-4, -2));
	p = p + (14400. * pre(-4, 0));
	p = p + (9450. * pre(-4, 2));
	p = p + (2520. * pre(-4, 4));
	p = p + (210. * pre(-4, 6));
	p = p + (120. * pre(-3, -7));
	p = p + (2100. * pre(-3, -5));
	p = p + (11340. * pre(-3, -3));
	p = p + (25200. * pre(-3, -1));
	p = p + (25200. * pre(-3, 1));
	p = p + (11340. * pre(-3, 3));
	p = p + (2100. * pre(-3, 5));
	p = p + (120. * pre(-3, 7));
	p = p + (45. * pre(-2, -8));
	p = p + (1200. * pre(-2, -6));
	p = p + (9450. * pre(-2, -4));
	p = p + (30240. * pre(-2, -2));
	p = p + (44100. * pre(-2, 0));
	p = p + (30240. * pre(-2, 2));
	p = p + (9450. * pre(-2, 4));
	p = p + (1200. * pre(-2, 6));
	p = p + (45. * pre(-2, 8));
	p = p + (10. * pre(-1, -9));
	p = p + (450. * pre(-1, -7));
	p = p + (5400. * pre(-1, -5));
	p = p + (25200. * pre(-1, -3));
	p = p + (52920. * pre(-1, -1));
	p = p + (52920. * pre(-1, 1));
	p = p + (25200. * pre(-1, 3));
	p = p + (5400. * pre(-1, 5));
	p = p + (450. * pre(-1, 7));
	p = p + (10. * pre(-1, 9));
	p = p + (1. * pre(0, -10));
	p = p + (100. * pre(0, -8));
	p = p + (2025. * pre(0, -6));
	p = p + (14400. * pre(0, -4));
	p = p + (44100. * pre(0, -2));
	p = p + (63504. * pre(0, 0));
	p = p + (44100. * pre(0, 2));
	p = p + (14400. * pre(0, 4));
	p = p + (2025. * pre(0, 6));
	p = p + (100. * pre(0, 8));
	p = p + (1. * pre(0, 10));
	p = p + (10. * pre(1, -9));
	p = p + (450. * pre(1, -7));
	p = p + (5400. * pre(1, -5));
	p = p + (25200. * pre(1, -3));
	p = p + (52920. * pre(1, -1));
	p = p + (52920. * pre(1, 1));
	p = p + (25200. * pre(1, 3));
	p = p + (5400. * pre(1, 5));
	p = p + (450. * pre(1, 7));
	p = p + (10. * pre(1, 9));
	p = p + (45. * pre(2, -8));
	p = p + (1200. * pre(2, -6));
	p = p + (9450. * pre(2, -4));
	p = p + (30240. * pre(2, -2));
	p = p + (44100. * pre(2, 0));
	p = p + (30240. * pre(2, 2));
	p = p + (9450. * pre(2, 4));
	p = p + (1200. * pre(2, 6));
	p = p + (45. * pre(2, 8));
	p = p + (120. * pre(3, -7));
	p = p + (2100. * pre(3, -5));
	p = p + (11340. * pre(3, -3));
	p = p + (25200. * pre(3, -1));
	p = p + (25200. * pre(3, 1));
	p = p + (11340. * pre(3, 3));
	p = p + (2100. * pre(3, 5));
	p = p + (120. * pre(3, 7));
	p = p + (210. * pre(4, -6));
	p = p + (2520. * pre(4, -4));
	p = p + (9450. * pre(4, -2));
	p = p + (14400. * pre(4, 0));
	p = p + (9450. * pre(4, 2));
	p = p + (2520. * pre(4, 4));
	p = p + (210. * pre(4, 6));
	p = p + (252. * pre(5, -5));
	p = p + (2100. * pre(5, -3));
	p = p + (5400. * pre(5, -1));
	p = p + (5400. * pre(5, 1));
	p = p + (2100. * pre(5, 3));
	p = p + (252. * pre(5, 5));
	p = p + (210. * pre(6, -4));
	p = p + (1200. * pre(6, -2));
	p = p + (2025. * pre(6, 0));
	p = p + (1200. * pre(6, 2));
	p = p + (210. * pre(6, 4));
	p = p + (120. * pre(7, -3));
	p = p + (450. * pre(7, -1));
	p = p + (450. * pre(7, 1));
	p = p + (120. * pre(7, 3));
	p = p + (45. * pre(8, -2));
	p = p + (100. * pre(8, 0));
	p = p + (45. * pre(8, 2));
	p = p + (10. * pre(9, -1));
	p = p + (10. * pre(9, 1));
	p = p + (1. * pre(10, 0));
	return p / 1048576.;
} 

@compute @workgroup_size(8, 8, 1)
fn update(@builtin(global_invocation_id) invocation_id: vec3<u32>) {
    let R: vec2<f32> = uni.iResolution.xy;
    let y_inverted_location = vec2<i32>(i32(invocation_id.x), i32(R.y) - i32(invocation_id.y));
    location = vec2<i32>(i32(invocation_id.x), i32(invocation_id.y));
    
	var fragColor: vec4<f32> = vec4<f32>(0.0, 0.0, 0.0, 0.0);
	var C = vec2<f32>(f32(location.x), f32(location.y) );

	let div: f32 = getDiv();
	let p: f32 = getPre() - div;
	fragColor = vec4<f32>(p, div, vec2<f32>(1.));

    textureStore(buffer_c, location, fragColor);
} 

